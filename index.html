<!DOCTYPE html>
<html lang="no">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stafsberg Golfsimulator - 3D Visualisering</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #1a1a1a;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px 25px;
            border-radius: 25px;
            z-index: 100;
            font-size: 0.85em;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
    <div id="controls">
        üñ±Ô∏è Klikk + dra = se deg rundt 360¬∞ | POV: 180cm h√∏yde, midt i rommet
    </div>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Room dimensions - MUST BE DEFINED FIRST
        const roomWidth = 3.70;
        const roomLength = 8;
        const roomHeight = 3.2;

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x2a2a2a);

        // Camera - POV from inside the room at 180cm height
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        // Position: center of room width, 1.8m height (180cm person), about 4m into the room
        camera.position.set(roomWidth/2, 1.8, 4);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Controls - look around only (no panning/zooming)
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.target.set(roomWidth/2, 1.8, 5); // Look slightly forward
        controls.enableZoom = false; // Disable zoom
        controls.enablePan = false; // Disable panning
        controls.rotateSpeed = 0.5; // Slower rotation for smoother look-around

        // Colors
        const darkBeige = 0x8c7b6b;
        const grayOak = 0x8b7355;
        const darkParquet = 0x3d2817;
        const artificialGrass = 0x2d5a27;
        const blackColor = 0x1a1a1a;

        // Materials
        const darkBeigeMaterial = new THREE.MeshLambertMaterial({ color: darkBeige });
        const grayOakMaterial = new THREE.MeshLambertMaterial({ color: grayOak });
        const parquetMaterial = new THREE.MeshLambertMaterial({ color: darkParquet });
        const grassMaterial = new THREE.MeshLambertMaterial({ color: artificialGrass });
        const blackMaterial = new THREE.MeshLambertMaterial({ color: blackColor });
        const whiteMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
        const windowMaterial = new THREE.MeshLambertMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.6 });
        const doorMaterial = new THREE.MeshLambertMaterial({ color: 0x4a4a4a });

        // Floor - Parquet section (first 4 meters from entrance)
        const parquetFloor = new THREE.Mesh(
            new THREE.BoxGeometry(roomWidth, 0.1, 4),
            parquetMaterial
        );
        parquetFloor.position.set(roomWidth/2, 0.05, 2);
        parquetFloor.receiveShadow = true;
        scene.add(parquetFloor);

        // Floor - Artificial grass section (last 4 meters)
        const grassFloor = new THREE.Mesh(
            new THREE.BoxGeometry(roomWidth, 0.1, 4),
            grassMaterial
        );
        grassFloor.position.set(roomWidth/2, 0.05, 6);
        grassFloor.receiveShadow = true;
        scene.add(grassFloor);

        // Ceiling - dark beige
        const ceiling = new THREE.Mesh(
            new THREE.BoxGeometry(roomWidth, 0.1, roomLength),
            darkBeigeMaterial
        );
        ceiling.position.set(roomWidth/2, roomHeight, roomLength/2);
        scene.add(ceiling);

        // Ceiling lights (two long fixtures)
        const lightFixtureMaterial = new THREE.MeshBasicMaterial({ color: 0xffffee });
        const lightFixture1 = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.05, 2),
            lightFixtureMaterial
        );
        lightFixture1.position.set(roomWidth/2, roomHeight - 0.08, 2);
        scene.add(lightFixture1);
        
        const lightFixture2 = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.05, 2),
            lightFixtureMaterial
        );
        lightFixture2.position.set(roomWidth/2, roomHeight - 0.08, 6);
        scene.add(lightFixture2);

        // Back wall (innerst - where screen is) - dark beige
        const backWall = new THREE.Mesh(
            new THREE.BoxGeometry(roomWidth, roomHeight, 0.1),
            darkBeigeMaterial
        );
        backWall.position.set(roomWidth/2, roomHeight/2, roomLength);
        scene.add(backWall);

        // Front wall (entrance side) - dark beige, with door opening on LEFT
        // Right part of front wall (main wall section)
        const frontWallRight = new THREE.Mesh(
            new THREE.BoxGeometry(roomWidth - 1.2, roomHeight, 0.1),
            darkBeigeMaterial
        );
        frontWallRight.position.set(roomWidth - (roomWidth - 1.2)/2, roomHeight/2, 0);
        scene.add(frontWallRight);

        // Top part above door
        const frontWallTop = new THREE.Mesh(
            new THREE.BoxGeometry(1.1, roomHeight - 2.1, 0.1),
            darkBeigeMaterial
        );
        frontWallTop.position.set(0.6, roomHeight - (roomHeight - 2.1)/2, 0);
        scene.add(frontWallTop);

        // DOOR on LEFT side of front wall
        const door = new THREE.Mesh(
            new THREE.BoxGeometry(0.9, 2.1, 0.08),
            doorMaterial
        );
        door.position.set(0.55, 1.05, 0.05);
        scene.add(door);

        // Door handle
        const doorHandle = new THREE.Mesh(
            new THREE.BoxGeometry(0.08, 0.15, 0.05),
            new THREE.MeshLambertMaterial({ color: 0xcccccc })
        );
        doorHandle.position.set(0.85, 1.0, 0.12);
        scene.add(doorHandle);

        // Door frame
        const doorFrameMaterial = new THREE.MeshLambertMaterial({ color: 0x5c5c5c });
        const doorFrameLeft = new THREE.Mesh(new THREE.BoxGeometry(0.08, 2.2, 0.12), doorFrameMaterial);
        doorFrameLeft.position.set(0.05, 1.1, 0.05);
        scene.add(doorFrameLeft);
        const doorFrameRight = new THREE.Mesh(new THREE.BoxGeometry(0.08, 2.2, 0.12), doorFrameMaterial);
        doorFrameRight.position.set(1.05, 1.1, 0.05);
        scene.add(doorFrameRight);
        const doorFrameTop = new THREE.Mesh(new THREE.BoxGeometry(1.1, 0.08, 0.12), doorFrameMaterial);
        doorFrameTop.position.set(0.55, 2.15, 0.05);
        scene.add(doorFrameTop);

        // LEFT wall (spiler/vinduer side) - BLACK background
        const leftWallBase = new THREE.Mesh(
            new THREE.BoxGeometry(0.1, roomHeight, roomLength),
            blackMaterial
        );
        leftWallBase.position.set(0, roomHeight/2, roomLength/2);
        scene.add(leftWallBase);

        // Window positions (z-coordinates)
        const window1Start = 1.25;
        const window1End = 2.75;
        const window2Start = 3.75;
        const window2End = 5.25;
        const windowBottom = 1.2;
        const windowTop = 2.4;

        // Windows on LEFT wall - visible through spiler
        const window1 = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, windowTop - windowBottom, window1End - window1Start),
            windowMaterial
        );
        window1.position.set(0.12, (windowTop + windowBottom)/2, (window1Start + window1End)/2);
        scene.add(window1);

        const window2 = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, windowTop - windowBottom, window2End - window2Start),
            windowMaterial
        );
        window2.position.set(0.12, (windowTop + windowBottom)/2, (window2Start + window2End)/2);
        scene.add(window2);

        // Window frames
        const windowFrameMaterial = new THREE.MeshLambertMaterial({ color: 0xeeeeee });
        
        function createWindowFrameLeft(zStart, zEnd) {
            const width = zEnd - zStart;
            const height = windowTop - windowBottom;
            const zCenter = (zStart + zEnd) / 2;
            const yCenter = (windowTop + windowBottom) / 2;
            
            // Frame pieces
            const top = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.06, width + 0.1), windowFrameMaterial);
            top.position.set(0.18, windowTop + 0.03, zCenter);
            scene.add(top);
            
            const bottom = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.06, width + 0.1), windowFrameMaterial);
            bottom.position.set(0.18, windowBottom - 0.03, zCenter);
            scene.add(bottom);
            
            const left = new THREE.Mesh(new THREE.BoxGeometry(0.06, height + 0.12, 0.06), windowFrameMaterial);
            left.position.set(0.18, yCenter, zStart - 0.03);
            scene.add(left);
            
            const right = new THREE.Mesh(new THREE.BoxGeometry(0.06, height + 0.12, 0.06), windowFrameMaterial);
            right.position.set(0.18, yCenter, zEnd + 0.03);
            scene.add(right);
        }
        
        createWindowFrameLeft(window1Start, window1End);
        createWindowFrameLeft(window2Start, window2End);

        // Spiler on LEFT wall - TETT I TETT, but skip window areas
        const spileWidth = 0.04;
        const spileGap = 0.015;
        const spileStep = spileWidth + spileGap;
        
        for (let z = 0.1; z < roomLength; z += spileStep) {
            // Skip window areas - leave gaps for windows
            const inWindow1 = z > window1Start - 0.1 && z < window1End + 0.1;
            const inWindow2 = z > window2Start - 0.1 && z < window2End + 0.1;
            
            if (!inWindow1 && !inWindow2) {
                // Full height spile
                const spile = new THREE.Mesh(
                    new THREE.BoxGeometry(0.05, roomHeight - 0.1, spileWidth),
                    grayOakMaterial
                );
                spile.position.set(0.12, roomHeight/2, z);
                scene.add(spile);
            } else {
                // Spile above window
                const spileTop = new THREE.Mesh(
                    new THREE.BoxGeometry(0.05, roomHeight - windowTop - 0.1, spileWidth),
                    grayOakMaterial
                );
                spileTop.position.set(0.12, windowTop + (roomHeight - windowTop)/2, z);
                scene.add(spileTop);
                
                // Spile below window
                const spileBottom = new THREE.Mesh(
                    new THREE.BoxGeometry(0.05, windowBottom - 0.1, spileWidth),
                    grayOakMaterial
                );
                spileBottom.position.set(0.12, windowBottom/2, z);
                scene.add(spileBottom);
            }
        }

        // LED lights between some spiler on LEFT wall
        const ledMaterial = new THREE.MeshBasicMaterial({ color: 0xffffcc, emissive: 0xffffcc });
        for (let i = 0; i < 12; i++) {
            const z = 0.5 + i * 0.65;
            // Skip LED in window areas
            const inWindow1 = z > window1Start && z < window1End;
            const inWindow2 = z > window2Start && z < window2End;
            if (!inWindow1 && !inWindow2) {
                const led = new THREE.Mesh(
                    new THREE.BoxGeometry(0.01, 0.5, 0.01),
                    ledMaterial
                );
                led.position.set(0.05, roomHeight/2 + 0.8, z);
                scene.add(led);
            }
        }

        // Trackman bench between windows on LEFT
        const bench = new THREE.Mesh(
            new THREE.BoxGeometry(0.5, 0.75, 0.8),
            grayOakMaterial
        );
        bench.position.set(0.35, 0.375, (window1End + window2Start)/2);
        bench.castShadow = true;
        scene.add(bench);

        // PC Monitor on bench
        const monitorStand = new THREE.Mesh(
            new THREE.BoxGeometry(0.1, 0.3, 0.1),
            blackMaterial
        );
        monitorStand.position.set(0.35, 0.9, (window1End + window2Start)/2);
        scene.add(monitorStand);

        const monitorScreen = new THREE.Mesh(
            new THREE.BoxGeometry(0.05, 0.4, 0.6),
            blackMaterial
        );
        monitorScreen.position.set(0.35, 1.2, (window1End + window2Start)/2);
        scene.add(monitorScreen);

        // Monitor screen glow
        const screenGlow = new THREE.Mesh(
            new THREE.BoxGeometry(0.01, 0.35, 0.55),
            new THREE.MeshBasicMaterial({ color: 0x3399ff })
        );
        screenGlow.position.set(0.32, 1.2, (window1End + window2Start)/2);
        scene.add(screenGlow);

        // RIGHT wall (sofa side) - dark beige
        const rightWall = new THREE.Mesh(
            new THREE.BoxGeometry(0.1, roomHeight, roomLength),
            darkBeigeMaterial
        );
        rightWall.position.set(roomWidth, roomHeight/2, roomLength/2);
        scene.add(rightWall);

        // Golf posters/pictures on RIGHT wall
        const posterMaterial1 = new THREE.MeshLambertMaterial({ color: 0x1a472a }); // Dark green
        const posterMaterial2 = new THREE.MeshLambertMaterial({ color: 0x2d5a27 }); // Golf green
        const posterMaterial3 = new THREE.MeshLambertMaterial({ color: 0x87CEEB }); // Sky blue
        const frameMat = new THREE.MeshLambertMaterial({ color: 0x2a2a2a });

        // Poster 1 on right wall - golf course landscape
        const poster1Frame = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.7, 1.0), frameMat);
        poster1Frame.position.set(roomWidth - 0.03, 1.8, 1.8);
        scene.add(poster1Frame);
        const poster1 = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.6, 0.9), posterMaterial3);
        poster1.position.set(roomWidth - 0.04, 1.8, 1.8);
        scene.add(poster1);
        // Green fairway detail
        const poster1Green = new THREE.Mesh(new THREE.BoxGeometry(0.01, 0.25, 0.85), posterMaterial2);
        poster1Green.position.set(roomWidth - 0.045, 1.55, 1.8);
        scene.add(poster1Green);

        // Poster 2 on right wall - Augusta style
        const poster2Frame = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.6, 0.8), frameMat);
        poster2Frame.position.set(roomWidth - 0.03, 1.8, 3.2);
        scene.add(poster2Frame);
        const poster2 = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.5, 0.7), posterMaterial1);
        poster2.position.set(roomWidth - 0.04, 1.8, 3.2);
        scene.add(poster2);

        // Poster on front wall (right side, next to door area)
        const poster3Frame = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.6, 0.04), frameMat);
        poster3Frame.position.set(2.2, 1.8, 0.03);
        scene.add(poster3Frame);
        const poster3 = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.5, 0.02), posterMaterial2);
        poster3.position.set(2.2, 1.8, 0.04);
        scene.add(poster3);
        // White golf ball detail
        const golfBall = new THREE.Mesh(new THREE.SphereGeometry(0.06, 16, 16), whiteMaterial);
        golfBall.position.set(2.2, 1.75, 0.06);
        scene.add(golfBall);

        // Corner sofa (RIGHT side near entrance) - slimmer
        const sofaSeat = new THREE.Mesh(
            new THREE.BoxGeometry(1.6, 0.35, 0.55),
            blackMaterial
        );
        sofaSeat.position.set(roomWidth - 0.85, 0.25, 0.45);
        sofaSeat.castShadow = true;
        scene.add(sofaSeat);

        const sofaBack = new THREE.Mesh(
            new THREE.BoxGeometry(1.6, 0.55, 0.12),
            blackMaterial
        );
        sofaBack.position.set(roomWidth - 0.85, 0.55, 0.15);
        scene.add(sofaBack);

        const sofaSide = new THREE.Mesh(
            new THREE.BoxGeometry(0.55, 0.35, 0.7),
            blackMaterial
        );
        sofaSide.position.set(roomWidth - 0.35, 0.25, 1.15);
        scene.add(sofaSide);

        const sofaSideBack = new THREE.Mesh(
            new THREE.BoxGeometry(0.12, 0.55, 0.8),
            blackMaterial
        );
        sofaSideBack.position.set(roomWidth - 0.1, 0.55, 1.1);
        scene.add(sofaSideBack);

        // Coffee table - RIGHT side (adjusted for slimmer sofa)
        const tableTop = new THREE.Mesh(
            new THREE.BoxGeometry(0.6, 0.04, 0.4),
            grayOakMaterial
        );
        tableTop.position.set(roomWidth - 1.3, 0.4, 0.9);
        tableTop.castShadow = true;
        scene.add(tableTop);

        const tableLeg1 = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.36, 0.04), blackMaterial);
        tableLeg1.position.set(roomWidth - 1.55, 0.18, 0.75);
        scene.add(tableLeg1);
        const tableLeg2 = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.36, 0.04), blackMaterial);
        tableLeg2.position.set(roomWidth - 1.05, 0.18, 0.75);
        scene.add(tableLeg2);
        const tableLeg3 = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.36, 0.04), blackMaterial);
        tableLeg3.position.set(roomWidth - 1.55, 0.18, 1.05);
        scene.add(tableLeg3);
        const tableLeg4 = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.36, 0.04), blackMaterial);
        tableLeg4.position.set(roomWidth - 1.05, 0.18, 1.05);
        scene.add(tableLeg4);

        // Mini fridge (RIGHT wall, after sofa) - smaller
        const fridge = new THREE.Mesh(
            new THREE.BoxGeometry(0.4, 0.6, 0.4),
            new THREE.MeshLambertMaterial({ color: 0x333333 })
        );
        fridge.position.set(roomWidth - 0.3, 0.3, 2.3);
        fridge.castShadow = true;
        scene.add(fridge);

        // Trash can - RIGHT side
        const trashCan = new THREE.Mesh(
            new THREE.CylinderGeometry(0.15, 0.12, 0.5, 16),
            new THREE.MeshLambertMaterial({ color: 0x444444 })
        );
        trashCan.position.set(roomWidth - 0.4, 0.25, 3.2);
        trashCan.castShadow = true;
        scene.add(trashCan);

        // Simulator enclosure/cage (black netting - 3m from back wall)
        const cageMaterial = new THREE.MeshLambertMaterial({ 
            color: 0x111111, 
            transparent: true, 
            opacity: 0.7,
            side: THREE.DoubleSide
        });

        // Cage left side
        const cageLeft = new THREE.Mesh(
            new THREE.BoxGeometry(0.05, roomHeight - 0.3, 3),
            cageMaterial
        );
        cageLeft.position.set(0.15, roomHeight/2, 6.5);
        scene.add(cageLeft);

        // Cage right side
        const cageRight = new THREE.Mesh(
            new THREE.BoxGeometry(0.05, roomHeight - 0.3, 3),
            cageMaterial
        );
        cageRight.position.set(roomWidth - 0.15, roomHeight/2, 6.5);
        scene.add(cageRight);

        // Cage front (with opening for hitting)
        const cageFrontTop = new THREE.Mesh(
            new THREE.BoxGeometry(roomWidth - 0.2, 0.8, 0.05),
            cageMaterial
        );
        cageFrontTop.position.set(roomWidth/2, roomHeight - 0.6, 5);
        scene.add(cageFrontTop);

        // Cage top
        const cageTop = new THREE.Mesh(
            new THREE.BoxGeometry(roomWidth - 0.2, 0.05, 3),
            cageMaterial
        );
        cageTop.position.set(roomWidth/2, roomHeight - 0.2, 6.5);
        scene.add(cageTop);

        // Projector screen (white, on back wall)
        const screen = new THREE.Mesh(
            new THREE.BoxGeometry(3, 2.2, 0.05),
            whiteMaterial
        );
        screen.position.set(roomWidth/2, 1.8, 7.9);
        scene.add(screen);

        // Screen frame
        const screenFrame = new THREE.MeshLambertMaterial({ color: 0x222222 });
        const frameT = new THREE.Mesh(new THREE.BoxGeometry(3.1, 0.08, 0.08), screenFrame);
        frameT.position.set(roomWidth/2, 2.95, 7.9);
        scene.add(frameT);
        const frameB = new THREE.Mesh(new THREE.BoxGeometry(3.1, 0.08, 0.08), screenFrame);
        frameB.position.set(roomWidth/2, 0.65, 7.9);
        scene.add(frameB);
        const frameL = new THREE.Mesh(new THREE.BoxGeometry(0.08, 2.4, 0.08), screenFrame);
        frameL.position.set(roomWidth/2 - 1.55, 1.8, 7.9);
        scene.add(frameL);
        const frameR = new THREE.Mesh(new THREE.BoxGeometry(0.08, 2.4, 0.08), screenFrame);
        frameR.position.set(roomWidth/2 + 1.55, 1.8, 7.9);
        scene.add(frameR);

        // Hitting mat on grass
        const hittingMat = new THREE.Mesh(
            new THREE.BoxGeometry(1.5, 0.03, 1.5),
            new THREE.MeshLambertMaterial({ color: 0x1a4d1a })
        );
        hittingMat.position.set(roomWidth/2, 0.12, 5.5);
        scene.add(hittingMat);

        // Lighting - inside room (brighter for POV)
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);

        // Ceiling lights
        const mainLight = new THREE.PointLight(0xffffff, 1.0, 20);
        mainLight.position.set(roomWidth/2, roomHeight - 0.3, 2);
        mainLight.castShadow = true;
        scene.add(mainLight);

        const mainLight2 = new THREE.PointLight(0xffffff, 1.0, 20);
        mainLight2.position.set(roomWidth/2, roomHeight - 0.3, 6);
        mainLight2.castShadow = true;
        scene.add(mainLight2);

        // Warm accent light for LED strips
        const ledLight = new THREE.PointLight(0xffffcc, 0.3, 5);
        ledLight.position.set(0.5, roomHeight/2, 4);
        scene.add(ledLight);

        // Light from windows
        const windowLight1 = new THREE.PointLight(0xffffff, 0.3, 4);
        windowLight1.position.set(0.5, 1.8, 2);
        scene.add(windowLight1);
        
        const windowLight2 = new THREE.PointLight(0xffffff, 0.3, 4);
        windowLight2.position.set(0.5, 1.8, 4.5);
        scene.add(windowLight2);

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
